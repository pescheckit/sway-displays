#!/bin/bash

# Generic display manager for Sway
# Usage: displays.sh <command> [args]

PROFILE_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/displays"
mkdir -p "$PROFILE_DIR"

# Get connected outputs as JSON
get_outputs() {
    swaymsg -t get_outputs -r
}

# List connected displays
cmd_list() {
    echo "Connected displays:"
    get_outputs | jq -r '.[] | "  \(.name) - \(.make) \(.model) (\(.current_mode.width)x\(.current_mode.height))"'
}

# Get effective dimensions (accounting for rotation and scale)
# Uses rect.width and rect.height which already account for rotation
get_effective_size() {
    local name="$1" rot="$2" scale="$3"

    # Get native resolution
    local native_w=$(get_outputs | jq -r '.[] | select(.name == "'"$name"'") | .current_mode.width')
    local native_h=$(get_outputs | jq -r '.[] | select(.name == "'"$name"'") | .current_mode.height')

    # Swap dimensions if rotated 90 or 270
    local w=$native_w
    local h=$native_h
    if [ "$rot" = "90" ] || [ "$rot" = "270" ]; then
        w=$native_h
        h=$native_w
    fi

    # Apply scale
    local eff_w=$(echo "$w / $scale" | bc)
    local eff_h=$(echo "$h / $scale" | bc)
    echo "$eff_w $eff_h"
}

# Interactive setup wizard
cmd_setup() {
    local outputs=($(get_outputs | jq -r '.[].name'))
    local count=${#outputs[@]}

    if [ "$count" -eq 0 ]; then
        echo "No displays found"
        exit 1
    fi

    echo "=== Display Setup Wizard ==="
    echo ""
    echo "Found $count display(s):"
    for i in "${!outputs[@]}"; do
        local name="${outputs[$i]}"
        local info=$(get_outputs | jq -r '.[] | select(.name == "'"$name"'") | "\(.make) \(.model) (\(.current_mode.width)x\(.current_mode.height))"')
        echo "  $((i+1)). $name - $info"
    done

    declare -A rotations scales pos_x pos_y
    local enabled_displays=()
    local to_disable=()

    echo ""
    echo "--- Step 1: Configure each display ---"
    echo "(y)es = enable, (n)o = disable, (s)kip = leave unchanged"
    echo ""

    # Configure each display (enable/disable, rotation, scale)
    for i in "${!outputs[@]}"; do
        local name="${outputs[$i]}"
        local info=$(get_outputs | jq -r '.[] | select(.name == "'"$name"'") | "\(.make) \(.model) (\(.current_mode.width)x\(.current_mode.height))"')
        echo "Display $((i+1))/$count: $name ($info)"

        read -r -p "  Enable? (y/n/s) [y]: " enable
        enable=${enable:-y}
        if [[ "$enable" == "n" || "$enable" == "N" ]]; then
            echo "  -> Will be disabled"
            to_disable+=("$name")
            echo ""
            continue
        elif [[ "$enable" == "s" || "$enable" == "S" ]]; then
            echo "  -> Skipped (unchanged)"
            echo ""
            continue
        fi

        read -r -p "  Rotation (0=normal, 90=right, 180=flip, 270=left) [0]: " rot
        rot=${rot:-0}
        case "$rot" in
            0)   rotations[$name]="normal" ;;
            90)  rotations[$name]="90" ;;
            180) rotations[$name]="180" ;;
            270) rotations[$name]="270" ;;
            *)   rotations[$name]="normal" ;;
        esac

        read -r -p "  Scale (1, 1.5, 2, etc.) [1]: " scale
        scales[$name]=${scale:-1}

        enabled_displays+=("$name")
        echo "  -> Enabled"
        echo ""
    done

    if [ ${#enabled_displays[@]} -eq 0 ]; then
        if [ ${#to_disable[@]} -eq 0 ]; then
            echo "No changes to apply!"
            exit 0
        fi
        # Only disabling displays, no arrangement needed
        echo "=== Applying configuration ==="
        for name in "${to_disable[@]}"; do
            swaymsg output "$name" disable
            echo "  $name: disabled"
        done
        echo ""
        read -r -p "Save as profile? (name or Enter to skip): " profile_name
        if [ -n "$profile_name" ]; then
            cmd_save "$profile_name"
        fi
        echo "Done!"
        return
    fi

    # Step 2: Arrange displays (only if more than one enabled)
    if [ ${#enabled_displays[@]} -gt 1 ]; then
        echo "--- Step 2: Arrange displays ---"
        echo ""
        echo "Enabled displays:"
        for i in "${!enabled_displays[@]}"; do
            local name="${enabled_displays[$i]}"
            local info=$(get_outputs | jq -r '.[] | select(.name == "'"$name"'") | "\(.model)"')
            read w h <<< $(get_effective_size "$name" "${rotations[$name]}" "${scales[$name]}")
            echo "  $((i+1)). $name ($info) - ${w}x${h}"
        done

        echo ""
        echo "Enter the order from LEFT to RIGHT (comma-separated numbers)"
        echo "Example: 2,1,3 means display 2 is leftmost, then 1, then 3"
        local default_order=$(seq -s, 1 ${#enabled_displays[@]})
        read -r -p "Order [$default_order]: " order_input
        order_input=${order_input:-$default_order}

        # Parse order into array
        IFS=',' read -ra order_nums <<< "$order_input"
        local arranged=()
        for num in "${order_nums[@]}"; do
            num=$(echo "$num" | tr -d ' ')  # trim spaces
            if [[ "$num" =~ ^[0-9]+$ ]] && [ "$num" -ge 1 ] && [ "$num" -le ${#enabled_displays[@]} ]; then
                arranged+=("${enabled_displays[$((num-1))]}")
            fi
        done

        # If parsing failed, use default order
        if [ ${#arranged[@]} -ne ${#enabled_displays[@]} ]; then
            echo "  Invalid order, using default left-to-right"
            arranged=("${enabled_displays[@]}")
        fi

        # Calculate positions based on arrangement
        # First display starts at 0,0
        local first_name="${arranged[0]}"
        read first_w first_h <<< $(get_effective_size "$first_name" "${rotations[$first_name]}" "${scales[$first_name]}")
        pos_x[$first_name]=0
        pos_y[$first_name]=0
        local x_pos=$first_w

        # For each subsequent display, ask how it aligns with the previous one
        for (( i=1; i<${#arranged[@]}; i++ )); do
            local prev_name="${arranged[$((i-1))]}"
            local curr_name="${arranged[$i]}"
            local prev_info=$(get_outputs | jq -r '.[] | select(.name == "'"$prev_name"'") | "\(.model)"')
            local curr_info=$(get_outputs | jq -r '.[] | select(.name == "'"$curr_name"'") | "\(.model)"')

            read prev_w prev_h <<< $(get_effective_size "$prev_name" "${rotations[$prev_name]}" "${scales[$prev_name]}")
            read curr_w curr_h <<< $(get_effective_size "$curr_name" "${rotations[$curr_name]}" "${scales[$curr_name]}")

            echo ""
            echo "How is $curr_name ($curr_info) aligned with $prev_name ($prev_info)?"
            read -r -p "  (t)op, (c)enter, (b)ottom [b]: " valign
            valign=${valign:-b}

            pos_x[$curr_name]=$x_pos
            local prev_y=${pos_y[$prev_name]}
            case "$valign" in
                t|top)    pos_y[$curr_name]=$prev_y ;;
                c|center) pos_y[$curr_name]=$((prev_y + (prev_h - curr_h) / 2)) ;;
                *)        pos_y[$curr_name]=$((prev_y + prev_h - curr_h)) ;;  # bottom
            esac
            x_pos=$((x_pos + curr_w))
        done

        # Normalize Y positions (shift so minimum Y is 0)
        local min_y=0
        for name in "${arranged[@]}"; do
            [ "${pos_y[$name]}" -lt "$min_y" ] && min_y=${pos_y[$name]}
        done
        for name in "${arranged[@]}"; do
            pos_y[$name]=$((pos_y[$name] - min_y))
        done

        # Show arrangement
        echo ""
        echo "Arrangement (left to right):"
        for name in "${arranged[@]}"; do
            local info=$(get_outputs | jq -r '.[] | select(.name == "'"$name"'") | "\(.model)"')
            echo "  $name ($info) at ${pos_x[$name]},${pos_y[$name]}"
        done
    else
        # Single display - just put at 0,0
        local name="${enabled_displays[0]}"
        pos_x[$name]=0
        pos_y[$name]=0
    fi

    if [ ${#enabled_displays[@]} -eq 0 ] && [ ${#to_disable[@]} -eq 0 ]; then
        echo "No changes to apply!"
        exit 0
    fi

    # Apply settings
    echo ""
    echo "=== Applying configuration ==="
    for name in "${enabled_displays[@]}"; do
        local x=${pos_x[$name]}
        local y=${pos_y[$name]}
        local rot="${rotations[$name]}"
        local scale="${scales[$name]}"
        echo "  $name: pos ${x},${y}, rotation $rot, scale $scale"
        swaymsg output "$name" enable pos "$x" "$y" scale "$scale" transform "$rot"
    done

    # Disable outputs explicitly marked for disable
    for name in "${to_disable[@]}"; do
        swaymsg output "$name" disable
        echo "  $name: disabled"
    done

    # Ask to save
    echo ""
    read -r -p "Save as profile? (name or Enter to skip): " profile_name
    if [ -n "$profile_name" ]; then
        cmd_save "$profile_name"
    fi

    echo "Done!"
}

# Install wl-mirror from source (for Debian 12 and others without package)
cmd_install_wl_mirror() {
    if command -v wl-mirror &>/dev/null; then
        echo "wl-mirror is already installed: $(which wl-mirror)"
        return 0
    fi

    echo "wl-mirror not found. Installing from source..."

    # Check for build dependencies
    local missing_deps=()
    for cmd in git cmake; do
        if ! command -v "$cmd" &>/dev/null; then
            missing_deps+=("$cmd")
        fi
    done

    if [ ${#missing_deps[@]} -gt 0 ]; then
        echo "Missing build tools: ${missing_deps[*]}"
        echo "Installing build dependencies..."
        sudo apt update
        sudo apt install -y git cmake libwayland-dev libepoxy-dev
    fi

    local build_dir="/tmp/wl-mirror-build"
    local src_dir="$build_dir/wl-mirror"
    rm -rf "$build_dir"
    mkdir -p "$build_dir"

    echo "Cloning wl-mirror..."
    git clone --recurse-submodules https://github.com/Ferdi265/wl-mirror.git "$src_dir"

    echo "Building..."
    cmake -B "$src_dir/build" -S "$src_dir" -DCMAKE_INSTALL_PREFIX=/usr/local
    cmake --build "$src_dir/build"

    echo "Installing..."
    sudo cmake --install "$src_dir/build"
    sudo ldconfig

    rm -rf "$build_dir"

    if command -v wl-mirror &>/dev/null; then
        echo "wl-mirror installed successfully!"
    else
        echo "Installation may have succeeded but wl-mirror not in PATH."
        echo "Try: /usr/local/bin/wl-mirror"
    fi
}

# Find sway-mirror binary
find_sway_mirror() {
    # Check if in PATH
    if command -v sway-mirror &>/dev/null; then
        echo "sway-mirror"
        return
    fi
    # Check user install location
    local user_path="${XDG_DATA_HOME:-$HOME/.local/share}/sway-mirror/target/release/sway-mirror"
    if [ -x "$user_path" ]; then
        echo "$user_path"
        return
    fi
    # Not found
    echo ""
}

# Install sway-mirror from GitHub
install_sway_mirror() {
    local install_dir="${XDG_DATA_HOME:-$HOME/.local/share}/sway-mirror"

    # Check for cargo
    if ! command -v cargo &>/dev/null; then
        echo "ERROR: Rust/Cargo is required to build sway-mirror"
        echo "Install Rust from https://rustup.rs/"
        return 1
    fi

    echo "Installing sway-mirror..."

    # Clone if not exists
    if [ ! -d "$install_dir" ]; then
        echo "Cloning sway-mirror..."
        git clone https://github.com/pescheckit/sway-mirror.git "$install_dir" || return 1
    fi

    # Build
    echo "Building sway-mirror (this may take a minute)..."
    (cd "$install_dir" && cargo build --release) || return 1

    if [ -x "$install_dir/target/release/sway-mirror" ]; then
        echo "sway-mirror installed successfully!"
        return 0
    else
        echo "Build failed"
        return 1
    fi
}

# Mirror displays using sway-mirror
cmd_mirror() {
    local source="$1"
    local outputs=($(get_outputs | jq -r '.[].name'))
    local count=${#outputs[@]}

    if [ "$count" -lt 2 ]; then
        echo "Need at least 2 displays to mirror"
        exit 1
    fi

    # Find sway-mirror binary
    local sway_mirror_bin=$(find_sway_mirror)
    if [ -z "$sway_mirror_bin" ]; then
        echo "sway-mirror not found."
        if ! command -v cargo &>/dev/null; then
            echo "Rust/Cargo is required to build sway-mirror."
            echo "Install Rust from https://rustup.rs/"
            exit 1
        fi
        read -r -p "Install it now? (y/n) [y]: " install
        install=${install:-y}
        if [[ "$install" == "y" || "$install" == "Y" ]]; then
            install_sway_mirror || exit 1
            sway_mirror_bin=$(find_sway_mirror)
        else
            echo "Mirroring requires sway-mirror. Aborting."
            exit 1
        fi
    fi

    # If no source specified, show menu
    if [ -z "$source" ]; then
        echo "Select source display (to mirror FROM):"
        for i in "${!outputs[@]}"; do
            local name="${outputs[$i]}"
            local info=$(get_outputs | jq -r '.[] | select(.name == "'"$name"'") | "\(.make) \(.model) (\(.current_mode.width)x\(.current_mode.height))"')
            echo "  $((i+1)). $name - $info"
        done
        read -r -p "Choice [1]: " choice
        choice=${choice:-1}
        if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
            choice=1
        fi
        source="${outputs[$((choice-1))]}"
    fi

    # Save current positions before mirroring (for unmirror to restore)
    get_outputs | jq '[.[] | {name: .name, x: .rect.x, y: .rect.y, scale: .scale, transform: .transform}]' > "$PROFILE_DIR/.pre_mirror.json"

    # Clear any existing pids file
    rm -f "$PROFILE_DIR/.mirror_pids"

    echo "Mirroring $source to all other displays..."

    # Build target list
    local targets=()
    for name in "${outputs[@]}"; do
        if [ "$name" != "$source" ]; then
            echo "  $name <- mirroring $source"
            targets+=("--to" "$name")
        fi
    done

    # Run sway-mirror (mirrors to all targets in one process)
    "$sway_mirror_bin" "$source" "${targets[@]}" &
    echo $! > "$PROFILE_DIR/.mirror_pids"

    echo ""
    echo "Mirroring active. Run 'sway-displays unmirror' to stop."
}

# Stop mirroring
cmd_unmirror() {
    local sway_mirror_bin=$(find_sway_mirror)

    if [ -n "$sway_mirror_bin" ]; then
        # Use sway-mirror's built-in stop (handles workspace restoration)
        "$sway_mirror_bin" --stop
    else
        # Fallback: kill any sway-mirror processes
        echo "Stopping sway-mirror..."
        pkill -f "sway-mirror" 2>/dev/null && echo "Stopped." || echo "No sway-mirror process found."
    fi

    # Clean up our tracking files
    rm -f "$PROFILE_DIR/.mirror_pids" "$PROFILE_DIR/.pre_mirror.json"
}

# Save current config as profile
cmd_save() {
    local name="$1"
    if [ -z "$name" ]; then
        read -r -p "Profile name: " name
    fi

    local file="$PROFILE_DIR/$name.json"

    # Check if profile already exists
    if [ -f "$file" ]; then
        echo "Profile '$name' already exists."
        read -r -p "Overwrite? (y/n) [n]: " overwrite
        if [[ "$overwrite" != "y" && "$overwrite" != "Y" ]]; then
            echo "Cancelled."
            return 1
        fi
    fi

    get_outputs | jq '[.[] | {name: .name, x: .rect.x, y: .rect.y, scale: .scale, transform: .transform, enabled: .dpms, make: .make, model: .model}]' > "$file"

    echo "Saved to $file"
}

# Load a profile
cmd_load() {
    local name="$1"

    if [ -z "$name" ]; then
        echo "Available profiles:"
        for f in "$PROFILE_DIR"/*.json; do
            [ -f "$f" ] && echo "  $(basename "$f" .json)"
        done
        echo ""
        read -r -p "Profile name: " name
    fi

    local file="$PROFILE_DIR/$name.json"
    if [ -f "$file" ]; then
        echo "Loading profile: $name"
        # Read JSON and apply each output config
        jq -c '.[]' "$file" | while read -r output; do
            local oname=$(echo "$output" | jq -r '.name')
            local x=$(echo "$output" | jq -r '.x')
            local y=$(echo "$output" | jq -r '.y')
            local scale=$(echo "$output" | jq -r '.scale')
            local transform=$(echo "$output" | jq -r '.transform')
            local enabled=$(echo "$output" | jq -r '.enabled')

            if [ "$enabled" = "true" ]; then
                echo "  $oname: pos $x,$y scale $scale transform $transform"
                swaymsg output "$oname" enable pos "$x" "$y" scale "$scale" transform "$transform"
            else
                echo "  $oname: disabled"
                swaymsg output "$oname" disable
            fi
        done
    else
        echo "Profile not found: $name"
        exit 1
    fi
}

# Show help
cmd_help() {
    echo "Display Manager for Sway"
    echo ""
    echo "Usage: sway-displays <command> [args]"
    echo ""
    echo "Commands:"
    echo "  list                  Show connected displays"
    echo "  setup                 Interactive setup wizard"
    echo "  mirror [output]       Mirror source display to all others"
    echo "  unmirror              Stop mirroring"
    echo "  install-wl-mirror     Install wl-mirror from source"
    echo "  save [name]           Save current config as profile"
    echo "  load [name]           Load a saved profile"
    echo "  profiles              List saved profiles"
    echo "  help                  Show this help"
    echo ""
    echo "Profiles are saved in: $PROFILE_DIR"
}

# List profiles
cmd_profiles() {
    echo "Saved profiles:"
    for f in "$PROFILE_DIR"/*.json; do
        [ -f "$f" ] && echo "  $(basename "$f" .json)"
    done 2>/dev/null
}

# Main
case "${1:-help}" in
    list)              cmd_list ;;
    setup)             cmd_setup ;;
    mirror)            cmd_mirror "$2" ;;
    unmirror)          cmd_unmirror ;;
    install-wl-mirror) cmd_install_wl_mirror ;;
    save)              cmd_save "$2" ;;
    load)              cmd_load "$2" ;;
    profiles)          cmd_profiles ;;
    help)              cmd_help ;;
    *)
        # Try to load as profile name
        if [ -f "$PROFILE_DIR/$1.json" ]; then
            cmd_load "$1"
        else
            echo "Unknown command: $1"
            cmd_help
            exit 1
        fi
        ;;
esac
